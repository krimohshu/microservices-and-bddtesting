package com.microservices.user.contract.provider;

import au.com.dius.pact.provider.junit5.HttpTestTarget;
import au.com.dius.pact.provider.junit5.PactVerificationContext;
import au.com.dius.pact.provider.junit5.PactVerificationInvocationContextProvider;
import au.com.dius.pact.provider.junitsupport.Provider;
import au.com.dius.pact.provider.junitsupport.State;
import au.com.dius.pact.provider.junitsupport.loader.PactFolder;
import com.microservices.user.model.User;
import com.microservices.user.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.TestTemplate;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;

/**
 * ðŸŽ¯ PROVIDER VERIFICATION TEST
 * 
 * This test verifies that User Service (the PROVIDER) correctly implements
 * the contract expectations defined by Order Service (the CONSUMER).
 * 
 * HOW IT WORKS:
 * 1. Reads the Pact file generated by Order Service consumer test
 * 2. Starts User Service on a random port
 * 3. For each interaction in the contract:
 *    - Sets up the required provider state (test data)
 *    - Replays the HTTP request against the REAL User Service API
 *    - Verifies the response matches what the consumer expects
 * 
 * KEY ANNOTATIONS:
 * - @Provider: Names this service as "user-service" (must match contract)
 * - @PactFolder: Points to where pact files are located (from consumer tests)
 * - @State: Sets up test data for specific provider states
 * - @TestTemplate: JUnit 5 annotation that runs test for each interaction
 * 
 * PROVIDER STATES:
 * Provider states are like "test scenarios" that define preconditions.
 * Example: "user with id 1 exists" means we need to have a user with ID 1 in the database.
 * 
 * WHY THIS IS IMPORTANT:
 * - Ensures User Service doesn't break Order Service's expectations
 * - Catches breaking changes before deployment
 * - Validates real API implementation (not mocks)
 * - Provides confidence that services can communicate
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Provider("user-service")  // ðŸ‘ˆ Must match the provider name in the Pact file
@PactFolder("../order-service/target/pacts")  // ðŸ‘ˆ Path to pact files from consumer (relative to project root)
public class UserServiceProviderPactTest {

    @LocalServerPort
    private int port;  // ðŸ‘ˆ Random port where User Service will run during test

    @Autowired
    private UserRepository userRepository;  // ðŸ‘ˆ Repository to set up test data

    /**
     * ðŸ”§ SETUP METHOD
     * 
     * This runs before each verification test.
     * It tells Pact where the User Service is running (localhost + random port).
     */
    @BeforeEach
    void setup(PactVerificationContext context) {
        System.out.println("\nðŸ”µ Setting up provider verification");
        System.out.println("ðŸ”µ User Service running on port: " + port);
        context.setTarget(new HttpTestTarget("localhost", port));
    }

    /**
     * ðŸ§ª TEST TEMPLATE METHOD
     * 
     * This is the actual test method that Pact uses to verify interactions.
     * The @TestTemplate annotation tells JUnit 5 to run this method multiple times,
     * once for each interaction in the Pact file.
     * 
     * For our contract (order-service-user-service.json), this will run TWICE:
     * 1. Once for "user with id 1 exists" (success case)
     * 2. Once for "user with id 999 does not exist" (404 case)
     */
    @TestTemplate
    @ExtendWith(PactVerificationInvocationContextProvider.class)
    void pactVerificationTestTemplate(PactVerificationContext context) {
        System.out.println("ðŸ”µ Verifying interaction: " + context.getInteraction().getDescription());
        context.verifyInteraction();  // ðŸ‘ˆ This replays the request and validates the response
        System.out.println("âœ… Interaction verified successfully!");
    }

    /**
     * ðŸŽ­ PROVIDER STATE: "user with id 1 exists"
     * 
     * This method is called BEFORE verifying the "get user by id" interaction.
     * It sets up the database so that a user with ID 1 exists.
     * 
     * WHAT HAPPENS:
     * 1. Pact sees the provider state "user with id 1 exists" in the contract
     * 2. Pact calls this @State method to set up test data
     * 3. Pact then makes the actual request: GET /api/v1/users/1
     * 4. User Service returns the user we just created
     * 5. Pact validates the response matches the contract expectations
     * 
     * WHY WE NEED THIS:
     * The consumer test defined that it expects a user with specific fields.
     * This method ensures that data exists so the API can return it.
     */
    @State("user with id 1 exists")
    public void userWithId1Exists() {
        System.out.println("\nðŸŽ­ Setting up provider state: user with id 1 exists");
        
        // Clear any existing data to avoid conflicts
        userRepository.deleteAll();
        
        // Create a user - don't set ID, let JPA generate it
        User user = new User();
        user.setUsername("johndoe");
        user.setEmail("john@example.com");
        user.setFirstName("John");
        user.setLastName("Doe");
        user.setPhone("+1234567890");
        user.setRole("USER");
        user.setStatus("ACTIVE");
        user.setActive(true);
        
        user = userRepository.save(user);
        
        System.out.println("âœ… User created with ID: " + user.getId());
        System.out.println("âœ… User details: " + user);
        System.out.println("ðŸ”µ Now User Service API will be called with GET /api/v1/users/" + user.getId());
    }

    /**
     * ðŸŽ­ PROVIDER STATE: "user with id 999 does not exist"
     * 
     * This method is called BEFORE verifying the "get non-existent user" interaction.
     * It ensures the database is clean so that user 999 does NOT exist.
     * 
     * WHAT HAPPENS:
     * 1. Pact sees the provider state "user with id 999 does not exist" in the contract
     * 2. Pact calls this @State method to ensure user 999 is not in database
     * 3. Pact then makes the actual request: GET /api/v1/users/999
     * 4. User Service returns 404 NOT FOUND (because user doesn't exist)
     * 5. Pact validates the 404 response matches the contract expectations
     * 
     * WHY WE NEED THIS:
     * The consumer test defined that it expects a 404 error for non-existent users.
     * This method ensures user 999 doesn't exist so the API returns 404.
     */
    @State("user with id 999 does not exist")
    public void userWithId999DoesNotExist() {
        System.out.println("\nðŸŽ­ Setting up provider state: user with id 999 does not exist");
        
        // Make sure user 999 does not exist
        userRepository.deleteById(999L);
        
        System.out.println("âœ… Ensured user 999 does not exist");
        System.out.println("ðŸ”µ Now User Service API will be called with GET /api/v1/users/999");
        System.out.println("ðŸ”µ Expected result: 404 NOT FOUND");
    }
}
